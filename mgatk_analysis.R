#!/usr/bin/env Rscript

# Combined R script for processing mgatk output, calling variants,
# filtering, and generating a cell-variant table.

# --- Libraries ---
suppressPackageStartupMessages(library(SummarizedExperiment))
suppressPackageStartupMessages(library(Matrix))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(tidyr)) # For pivot_longer
suppressPackageStartupMessages(library(optparse)) # For command-line arguments
suppressPackageStartupMessages(library(logr))    # For simple logging

# --- Argument Parsing ---
option_list <- list(
  make_option(c("-r", "--rds_file"), type = "character", default = NULL,
              help = "Path to the input .rds file generated by mgatk (e.g., sample/final/sample.rds)", metavar = "character"),
  make_option(c("-o", "--output_prefix"), type = "character", default = "mgatk_filtered_variants",
              help = "Prefix for the output CSV file name [default= %default]", metavar = "character"),
  make_option(c("--min_cells_conf_detected"), type = "integer", default = 5,
              help = "Minimum number of cells confidently detected (>=2 reads on FWD and REV strands) for initial variant filtering [default= %default]", metavar = "integer"),
  make_option(c("--min_cells_over_10"), type = "integer", default = 10,
              help = "Minimum number of cells with AF > 0.10 for initial variant filtering [default= %default]", metavar = "integer"),
  make_option(c("--min_strand_cor"), type = "double", default = 0.65,
              help = "Minimum strand correlation for initial variant filtering [default= %default]", metavar = "double"),
  make_option(c("--min_vmr"), type = "double", default = -Inf, # Effectively disables VMR filtering by default unless set
              help = "Minimum log10(VMR) for initial variant filtering [default= %default]", metavar = "double"),
  make_option(c("--min_dp"), type = "integer", default = 10,
              help = "Minimum read depth (coverage) per cell for a variant to be kept [default= %default]", metavar = "integer"),
  make_option(c("--min_af"), type = "double", default = 0.03,
              help = "Minimum allele frequency (AF) per cell for a variant to be kept [default= %default]", metavar = "double"),
  make_option(c("--max_af"), type = "double", default = 0.97,
              help = "Maximum allele frequency (AF) per cell for a variant to be kept (filters likely germline) [default= %default]", metavar = "double"),
  make_option(c("--stabilize_variance"), type = "logical", default = TRUE,
              help = "Stabilize variance by replacing low coverage cells with mean? [default= %default]", metavar = "logical"),
  make_option(c("--low_coverage_threshold"), type = "integer", default = 10,
              help = "Coverage threshold used if stabilize_variance is TRUE [default= %default]", metavar = "integer"),
  make_option(c("-l", "--log_file"), type = "character", default = NULL,
              help = "Optional file path for logging output.", metavar = "character")
)

opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)

# --- Setup Logging ---
if (!is.null(opt$log_file)) {
    log_open(opt$log_file, logdir = FALSE, show_notes = FALSE)
} else {
    log_open(stdout()) # Log to console if no file specified
}

# --- Input Validation ---
if (is.null(opt$rds_file)) {
  log_print("Error: Input RDS file path (--rds_file) is required.", hide_notes = TRUE)
  print_help(opt_parser)
  stop("Input RDS file not specified.", call. = FALSE)
}
if (!file.exists(opt$rds_file)) {
  log_print(paste("Error: Input RDS file not found:", opt$rds_file), hide_notes = TRUE)
  stop("Input RDS file not found.", call. = FALSE)
}

log_print("--- Starting mgatk Variant Processing ---", hide_notes = TRUE)
log_print(paste("Input RDS:", opt$rds_file), hide_notes = TRUE)
log_print(paste("Output Prefix:", opt$output_prefix), hide_notes = TRUE)
log_print("Parameters:", hide_notes = TRUE)
log_print(paste("  min_cells_conf_detected:", opt$min_cells_conf_detected), hide_notes = TRUE)
log_print(paste("  min_cells_over_10:", opt$min_cells_over_10), hide_notes = TRUE)
log_print(paste("  min_strand_cor:", opt$min_strand_cor), hide_notes = TRUE)
log_print(paste("  min_vmr (log10):", opt$min_vmr), hide_notes = TRUE)
log_print(paste("  min_dp:", opt$min_dp), hide_notes = TRUE)
log_print(paste("  min_af:", opt$min_af), hide_notes = TRUE)
log_print(paste("  max_af:", opt$max_af), hide_notes = TRUE)
log_print(paste("  stabilize_variance:", opt$stabilize_variance), hide_notes = TRUE)
log_print(paste("  low_coverage_threshold:", opt$low_coverage_threshold), hide_notes = TRUE)

# --- Helper Function ---
"%ni%" <- Negate("%in%")

# --- Core Variant Calling Function (from mgatk_variant_calling_func.R) ---
call_mutations_mgatk <- function(SE, stabilize_variance = TRUE, low_coverage_threshold = 10) {

  log_print("Starting call_mutations_mgatk function...", hide_notes = TRUE)
  # Determine key coverage statistics
  cov <- assays(SE)[["coverage"]]
  if (is.null(cov)) {
      stop("Coverage matrix not found in SummarizedExperiment assays.")
  }
  ref_allele <- toupper(as.character(rowRanges(SE)$refAllele))
  if (length(ref_allele) == 0) {
      stop("Reference allele information not found in SummarizedExperiment rowRanges.")
  }

  # Process mutation for one alternate letter
  process_letter <- function(letter) {
    log_print(paste("Processing alternate allele:", letter), hide_notes = TRUE)
    # Filter for positions where the reference is not this letter and not 'N'
    boo <- ref_allele != letter & ref_allele != "N"
    if (sum(boo) == 0) {
        log_print(paste("  No variants possible for alternate allele", letter), hide_notes = TRUE)
        return(NULL) # Return NULL if no variants are possible for this letter
    }
    pos <- start(rowRanges(SE))
    variant_name <- paste0(ref_allele, as.character(pos), letter)[boo]
    nucleotide <- paste0(ref_allele, ">", letter)[boo]
    position_filt <- pos[boo]

    # Check if required assays exist
    fw_assay_name <- paste0(letter, "_counts_fw")
    rev_assay_name <- paste0(letter, "_counts_rev")
    if (!fw_assay_name %in% names(assays(SE)) || !rev_assay_name %in% names(assays(SE))) {
        log_print(paste("  Skipping letter", letter, "- missing required count assays:", fw_assay_name, "or", rev_assay_name), hide_notes = TRUE)
        return(NULL)
    }

    # Get allele frequency matrix
    mat_fw_count <- assays(SE)[[fw_assay_name]][boo, , drop = FALSE]
    mat_rev_count <- assays(SE)[[rev_assay_name]][boo, , drop = FALSE]
    mat_cov_count <- cov[boo, , drop = FALSE] # Use pre-calculated coverage

    # Calculate allele frequency, handling potential division by zero
    mat_af <- (mat_fw_count + mat_rev_count) / mat_cov_count
    mat_af[mat_cov_count == 0] <- 0 # Set AF to 0 where coverage is 0
    mat_af <- as(mat_af, "dgCMatrix")
    rownames(mat_af) <- variant_name

    # Calculate bulk allele frequency
    bulk_sum_alt <- Matrix::rowSums(mat_fw_count + mat_rev_count)
    bulk_sum_cov <- Matrix::rowSums(mat_cov_count)
    mean_af <- bulk_sum_alt / bulk_sum_cov
    mean_af[bulk_sum_cov == 0] <- 0 # Handle division by zero for bulk
    mean_af <- update_missing_w_zero(mean_af) # Ensure no NA/NaN

    # Helper function for row variances of sparse matrices
    rowVars_sparse <- function(x) {
      n <- ncol(x)
      if (n <= 1) return(rep(0, nrow(x)))
      rowMeans_x <- Matrix::rowMeans(x)
      rowVars_val <- Matrix::rowMeans(x^2) - rowMeans_x^2
      # Adjust for sample variance (n / (n - 1)) - use with caution for sparse data interpretation
      # rowVars_val <- rowVars_val * (n / (n - 1))
      return(pmax(0, rowVars_val)) # Ensure non-negative variance
    }

    update_missing_w_zero <- function(vec) {
      ifelse(is.na(vec) | is.nan(vec) | is.infinite(vec), 0, vec)
    }

    # Calculate strand correlation
    dt_fw <- data.table(Matrix::summary(mat_fw_count))
    setnames(dt_fw, c("i", "j", "forward"))
    dt_rev <- data.table(Matrix::summary(mat_rev_count))
    setnames(dt_rev, c("i", "j", "reverse"))

    # Full join on variant index (i) and cell index (j)
    dt_merged <- merge(dt_fw, dt_rev, by = c("i", "j"), all = TRUE)
    dt_merged[is.na(forward), forward := 0]
    dt_merged[is.na(reverse), reverse := 0]

    # Keep only entries where at least one strand has counts > 0
    dt_merged <- dt_merged[forward > 0 | reverse > 0]

    # Calculate correlation per variant (i)
    # Handle cases with insufficient data points for correlation (results in NA)
    cor_dt <- dt_merged[, .(cor = if (.N >= 2) cor(forward, reverse, method = "pearson", use = "pairwise.complete") else NA_real_), by = i]

    # Create a full vector of correlations, filling NAs for variants with no/low data
    cor_vec_val <- rep(NA_real_, length(variant_name))
    names(cor_vec_val) <- variant_name
    cor_vec_val[variant_name[cor_dt$i]] <- cor_dt$cor
    # Optionally replace NA correlations with 0 or another value if desired for filtering
    # cor_vec_val[is.na(cor_vec_val)] <- 0

    # Stabilize variances by replacing low coverage cells with mean AF for that variant
    if (stabilize_variance) {
      log_print(paste("  Stabilizing variance for", letter, "(low coverage threshold:", low_coverage_threshold, ")"), hide_notes = TRUE)
      # Get indices of cell/variants where the coverage is low
      idx_mat <- which(as.matrix(mat_cov_count < low_coverage_threshold), arr.ind = TRUE)

      if (nrow(idx_mat) > 0) {
          # Create a temporary dense matrix for modification (sparse updates can be complex)
          mat_af_dense <- as.matrix(mat_af)
          # Get the mean AF for the variants needing stabilization
          idx_mat_mean <- mean_af[idx_mat[, "row"]]
          # Replace low-coverage AF values with the mean AF for that variant
          mat_af_dense[idx_mat] <- idx_mat_mean
          # Calculate variance on the stabilized dense matrix
          variance <- matrixStats::rowVars(mat_af_dense)
          rm(mat_af_dense) # Clean up memory
      } else {
           log_print(paste("  No cells below threshold for", letter, "- calculating variance on original AF matrix."), hide_notes = TRUE)
           variance <- rowVars_sparse(mat_af) # Use sparse calculation if no stabilization needed
      }

    } else {
      log_print(paste("  Calculating variance on original AF matrix for", letter), hide_notes = TRUE)
      variance <- rowVars_sparse(mat_af)
    }
    variance <- update_missing_w_zero(variance) # Ensure no NA/NaN

    # Calculate confident detection (>=2 reads on both strands)
    detected_fw <- mat_fw_count >= 2
    detected_rev <- mat_rev_count >= 2
    n_cells_conf_detected <- Matrix::rowSums(detected_fw & detected_rev)

    # Compute per-mutation summary statistics
    var_summary_df <- data.frame(
      position = position_filt,
      nucleotide = nucleotide,
      variant = variant_name,
      vmr = variance / (mean_af + 1e-12), # Add small epsilon to avoid division by zero
      mean = round(mean_af, 7),
      variance = round(variance, 7),
      n_cells_conf_detected = n_cells_conf_detected,
      n_cells_over_5 = Matrix::rowSums(mat_af >= 0.05),
      n_cells_over_10 = Matrix::rowSums(mat_af >= 0.10),
      n_cells_over_20 = Matrix::rowSums(mat_af >= 0.20),
      strand_correlation = cor_vec_val[variant_name], # Use the vector with potential NAs
      mean_coverage = Matrix::rowMeans(mat_cov_count),
      stringsAsFactors = FALSE, row.names = variant_name
    )

    # Create a new SummarizedExperiment for this letter's variants
    se_new <- SummarizedExperiment(
      rowData = var_summary_df,
      colData = colData(SE), # Keep original cell metadata
      assays = list(allele_frequency = mat_af, coverage = mat_cov_count) # Include AF and coverage
    )
    log_print(paste("  Finished processing", letter, "- found", nrow(se_new), "potential variants."), hide_notes = TRUE)
    return(se_new)
  }

  # Process each alternate allele and combine results
  results_list <- list(
      process_letter("A"),
      process_letter("C"),
      process_letter("G"),
      process_letter("T")
  )

  # Filter out NULL results (e.g., if an assay was missing)
  results_list <- results_list[!sapply(results_list, is.null)]

  if (length(results_list) == 0) {
      log_print("No valid variants found after processing all letters.", hide_notes = TRUE)
      return(NULL) # Return NULL if no variants were found across all letters
  }

  log_print("Combining results from all alternate alleles.", hide_notes = TRUE)
  final_se <- do.call(SummarizedExperiment::rbind, results_list)
  log_print("Finished call_mutations_mgatk function.", hide_notes = TRUE)
  return(final_se)
}


# --- Main Workflow ---

# 1. Load the mgatk RDS object
log_print(paste("Loading mgatk RDS object:", opt$rds_file), hide_notes = TRUE)
mgatk_obj <- readRDS(opt$rds_file)
log_print(paste("Loaded object with", ncol(mgatk_obj), "cells and", nrow(mgatk_obj), "positions."), hide_notes = TRUE)

# Check basic structure
if (!"coverage" %in% names(assays(mgatk_obj))) {
    log_print("Error: Input RDS is missing the 'coverage' assay.", hide_notes = TRUE)
    stop("Input RDS is missing the 'coverage' assay.")
}
if (!"refAllele" %in% colnames(rowData(mgatk_obj))) {
     log_print("Error: Input RDS is missing 'refAllele' in rowData.", hide_notes = TRUE)
    stop("Input RDS is missing 'refAllele' in rowData.")
}

# 2. Call Variants using the function
mgatk_mut <- call_mutations_mgatk(mgatk_obj,
                                  stabilize_variance = opt$stabilize_variance,
                                  low_coverage_threshold = opt$low_coverage_threshold)

if (is.null(mgatk_mut) || nrow(mgatk_mut) == 0) {
    log_print("No variants were generated by call_mutations_mgatk. Exiting.", hide_notes = TRUE)
    log_close()
    quit(save = "no", status = 0) # Exit gracefully if no variants
}

log_print(paste("Generated", nrow(mgatk_mut), "total potential variants across all cells."), hide_notes = TRUE)

# 3. Initial Variant Filtering (based on rowData summaries)
variant_stats_df <- as.data.frame(rowData(mgatk_mut))

log_print("Applying initial variant filters:", hide_notes = TRUE)
log_print(paste("  Initial variants:", nrow(variant_stats_df)), hide_notes = TRUE)

filtered_variants <- variant_stats_df %>%
  dplyr::filter(
    n_cells_conf_detected >= opt$min_cells_conf_detected,
    n_cells_over_10 >= opt$min_cells_over_10,
    (is.na(strand_correlation) | strand_correlation >= opt$min_strand_cor), # Keep variants if correlation is NA or >= threshold
    log10(vmr + 1e-12) >= opt$min_vmr # Add epsilon to vmr for log10 calculation
  )

log_print(paste("  Variants remaining after initial filtering:", nrow(filtered_variants)), hide_notes = TRUE)

if (nrow(filtered_variants) == 0) {
  log_print("No variants passed the initial filtering criteria. Exiting.", hide_notes = TRUE)
  log_close()
  quit(save = "no", status = 0) # Exit gracefully if no variants pass filters
}

# 4. Extract AF and DP for filtered variants across all cells
filtered_variant_ids <- as.character(filtered_variants$variant)
cell_ids <- colnames(mgatk_mut) # Or use mgatk_mut$sample if that column exists in colData

log_print("Extracting Allele Frequency (AF) and Depth (DP) for filtered variants.", hide_notes = TRUE)
variant_tbl_DP <- assays(mgatk_mut)[["coverage"]][filtered_variant_ids, , drop = FALSE]
variant_tbl_AF <- assays(mgatk_mut)[["allele_frequency"]][filtered_variant_ids, , drop = FALSE]

# Convert sparse matrices to long data tables for efficiency
summary_DP <- summary(variant_tbl_DP)
summary_AF <- summary(variant_tbl_AF)

dt_DP <- data.table(
    variant_idx = summary_DP$i,
    cell_idx = summary_DP$j,
    DP = summary_DP$x
)
dt_AF <- data.table(
    variant_idx = summary_AF$i,
    cell_idx = summary_AF$j,
    AF = summary_AF$x
)

# Map indices back to names
variant_names <- rownames(variant_tbl_DP) # Same as filtered_variant_ids
cell_names <- colnames(variant_tbl_DP)    # Same as cell_ids

dt_DP[, variant_id := variant_names[variant_idx]]
dt_DP[, cell_id := cell_names[cell_idx]]
dt_AF[, variant_id := variant_names[variant_idx]]
dt_AF[, cell_id := cell_names[cell_idx]]

# Merge DP and AF tables based on variant and cell
# Use a full join to keep all observations initially, then filter
# Need only variant_id, cell_id, DP, AF columns
log_print("Merging DP and AF tables.", hide_notes = TRUE)
variant_cell_tbl <- merge(
    dt_DP[, .(variant_id, cell_id, DP)],
    dt_AF[, .(variant_id, cell_id, AF)],
    by = c("variant_id", "cell_id"),
    all = TRUE # Keep all cell-variant pairs that have either DP or AF > 0
)

# Fill potentially missing values introduced by merging sparse data (where AF=0 or DP=0 wasn't explicitly stored)
# If DP exists but AF doesn't, AF should be 0.
# If AF exists but DP doesn't, this indicates an issue (shouldn't happen if AF > 0). Let's assume DP=0 is impossible if AF>0.
# We primarily care about entries where AF > 0, and these should always have DP > 0 from mgatk.
# Let's filter first, then check for NAs.
variant_cell_tbl <- variant_cell_tbl[!is.na(AF) & !is.na(DP)] # Remove rows where merge failed unexpectedly

log_print(paste("Generated table with", nrow(variant_cell_tbl), "cell-variant entries (AF > 0 or DP > 0)."), hide_notes = TRUE)

# 5. Apply Cell-Level Filtering (DP and AF thresholds)
log_print("Applying cell-level filters (DP, AF range).", hide_notes = TRUE)
variant_cell_tbl_filtered <- variant_cell_tbl %>%
  filter(DP >= opt$min_dp & AF >= opt$min_af & AF <= opt$max_af)

log_print(paste("Final filtered table contains", nrow(variant_cell_tbl_filtered), "cell-variant entries."), hide_notes = TRUE)

# 6. Save the final filtered table
output_filename <- paste0(opt$output_prefix, "_filtered_cell_variants.csv")
log_print(paste("Saving filtered cell-variant table to:", output_filename), hide_notes = TRUE)
fwrite(variant_cell_tbl_filtered, file = output_filename, row.names = FALSE, quote = FALSE)

log_print("--- Processing Complete ---", hide_notes = TRUE)
log_close()
